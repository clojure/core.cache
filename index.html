<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>clojure.core.cache - core.cache 1.0.226-SNAPSHOT API documentation</title>
    <link rel="icon" href="static/favicon.png" />
    <link rel="shortcut icon" href="static/favicon.png" />
    <link rel="stylesheet" href="static/clojure.css" type="text/css" media="all" />
    <link rel="stylesheet" href="static/wiki.css" type="text/css" media="all" />
    <link rel="stylesheet" href="static/internal.css" type="text/css" media="all" />
    <style>.menuWrapper{height: 36px;}</style>
  </head>
<!--
This document was auto-generated from the source by the clojure autodoc system.
To report errors or ask questions about the overall documentation structure, formatting,
etc., contact Tom Faulhaber (google mail name: tomfaulhaber).
For errors in the documentation of a particular namespace, contact the author of that
namespace.
-->
  <body>
    <div id="AllContentContainer">
      <div id="Header">
	<a href="index.html" id="Logo"><img src="static/clojure-icon.gif" width="100" height="100" alt="Clojure" /></a>
	<h1><a href="index.html" id="page-header" title="page header title">core.cache API Reference</a></h1>
      </div>
      <div id="leftcolumn"><div style="text-align: center;"></div>
<div class="menu">
  <div class="WikiCustomNav WikiElement wiki">
    <span class="toc-header"><span id="project-name">core.cache</span> <span id="version">1.0.226-SNAPSHOT</span> API</span><br />
    <ul>
      <li><a href="index.html" class="wiki_link">Overview</a></li>
      <li><a href="api-index.html" class="wiki_link">API Index</a></li>
    </ul>
    
    
    <a class="wiki_link" href="https://clojure.org">Clojure Home</a>
  </div>
</div>
</div>
      <div id="rightcolumn">
	<div id="Content">
	  <div class="contentBox"><div class="innerContentBox">
              <div class="wiki wikiPage" id="content_view">
                <div id="right-sidebar"><div id="toc">
  <h1 class="nopad">Table of Contents</h1>
  <div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#toc0">Overview</a>
    
  </div><div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#proto-section">Protocols</a>
    <div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.cache/CacheProtocol" class="toc-entry-anchor">CacheProtocol</a>
      <div class="toc-subentry" style="margin-left: 1em;">
        <a href="#clojure.core.cache/evict" class="toc-subentry-anchor">evict</a>
      </div><div class="toc-subentry" style="margin-left: 1em;">
        <a href="#clojure.core.cache/has?" class="toc-subentry-anchor">has?</a>
      </div><div class="toc-subentry" style="margin-left: 1em;">
        <a href="#clojure.core.cache/hit" class="toc-subentry-anchor">hit</a>
      </div><div class="toc-subentry" style="margin-left: 1em;">
        <a href="#clojure.core.cache/lookup" class="toc-subentry-anchor">lookup</a>
      </div><div class="toc-subentry" style="margin-left: 1em;">
        <a href="#clojure.core.cache/miss" class="toc-subentry-anchor">miss</a>
      </div><div class="toc-subentry" style="margin-left: 1em;">
        <a href="#clojure.core.cache/seed" class="toc-subentry-anchor">seed</a>
      </div>
    </div>
  </div><div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#type-section">Types</a>
    <div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.cache/BasicCache" class="toc-entry-anchor">BasicCache</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.cache/FIFOCache" class="toc-entry-anchor">FIFOCache</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.cache/FnCache" class="toc-entry-anchor">FnCache</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.cache/LIRSCache" class="toc-entry-anchor">LIRSCache</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.cache/LRUCache" class="toc-entry-anchor">LRUCache</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.cache/LUCache" class="toc-entry-anchor">LUCache</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.cache/SoftCache" class="toc-entry-anchor">SoftCache</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.cache/TTLCacheQ" class="toc-entry-anchor">TTLCacheQ</a>
      
    </div>
  </div><div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#var-section">Vars and Functions</a>
    <div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.cache/-&gt;BasicCache" class="toc-entry-anchor">-&gt;BasicCache</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.cache/-&gt;FIFOCache" class="toc-entry-anchor">-&gt;FIFOCache</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.cache/-&gt;FnCache" class="toc-entry-anchor">-&gt;FnCache</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.cache/-&gt;LIRSCache" class="toc-entry-anchor">-&gt;LIRSCache</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.cache/-&gt;LRUCache" class="toc-entry-anchor">-&gt;LRUCache</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.cache/-&gt;LUCache" class="toc-entry-anchor">-&gt;LUCache</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.cache/-&gt;SoftCache" class="toc-entry-anchor">-&gt;SoftCache</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.cache/-&gt;TTLCacheQ" class="toc-entry-anchor">-&gt;TTLCacheQ</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.cache/basic-cache-factory" class="toc-entry-anchor">basic-cache-factory</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.cache/fifo-cache-factory" class="toc-entry-anchor">fifo-cache-factory</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.cache/lirs-cache-factory" class="toc-entry-anchor">lirs-cache-factory</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.cache/lru-cache-factory" class="toc-entry-anchor">lru-cache-factory</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.cache/lu-cache-factory" class="toc-entry-anchor">lu-cache-factory</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.cache/soft-cache-factory" class="toc-entry-anchor">soft-cache-factory</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.cache/through" class="toc-entry-anchor">through</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.cache/through-cache" class="toc-entry-anchor">through-cache</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.cache/ttl-cache-factory" class="toc-entry-anchor">ttl-cache-factory</a>
      
    </div>
  </div><div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#"></a>
    
  </div><div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#clojure.core.cache.wrapped">clojure.core.cache.wrapped</a>
    <div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.cache.wrapped/basic-cache-factory" class="toc-entry-anchor">basic-cache-factory</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.cache.wrapped/evict" class="toc-entry-anchor">evict</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.cache.wrapped/fifo-cache-factory" class="toc-entry-anchor">fifo-cache-factory</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.cache.wrapped/has?" class="toc-entry-anchor">has?</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.cache.wrapped/hit" class="toc-entry-anchor">hit</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.cache.wrapped/lirs-cache-factory" class="toc-entry-anchor">lirs-cache-factory</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.cache.wrapped/lookup" class="toc-entry-anchor">lookup</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.cache.wrapped/lookup-or-miss" class="toc-entry-anchor">lookup-or-miss</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.cache.wrapped/lru-cache-factory" class="toc-entry-anchor">lru-cache-factory</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.cache.wrapped/lu-cache-factory" class="toc-entry-anchor">lu-cache-factory</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.cache.wrapped/miss" class="toc-entry-anchor">miss</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.cache.wrapped/seed" class="toc-entry-anchor">seed</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.cache.wrapped/soft-cache-factory" class="toc-entry-anchor">soft-cache-factory</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.cache.wrapped/through" class="toc-entry-anchor">through</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.cache.wrapped/through-cache" class="toc-entry-anchor">through-cache</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.cache.wrapped/ttl-cache-factory" class="toc-entry-anchor">ttl-cache-factory</a>
      
    </div>
  </div>
</div>
</div>
                <div id="content-tag"><h1 id="overview">API for <span id="clojure.core.cache">clojure.core.cache</span>
  - <span id="header-project">core.cache</span> <span id="header-version">1.0.226-SNAPSHOT</span><span id="header-status-block"> (<span id="header-status">in development</span>)</span>
  </h1>
<span id="author-line">by <span id="author-name">Fogus</span><br /></span>
<br />Full namespace name: <span id="long-name">clojure.core.cache</span>
<p></p>
<h2>Overview</h2>
<div id="home-page">Project home page is <a href="https://github.com/clojure/core.cache/">https://github.com/clojure/core.cache/</a></div>
<pre id="namespace-docstr">A caching library for Clojure.</pre>


<br />

<div id="proto-section">
  <p></p>
  <h2>Protocols</h2>
  <div id="proto-entry">
    <br />
    <hr />
    <h2 id="clojure.core.cache/CacheProtocol">CacheProtocol</h2>
    <span id="proto-type">Protocol</span><br />
    <pre id="proto-docstr">This is the protocol describing the basic cache capability.</pre>
    Known implementations: <span id="proto-impls"><a href="#clojure.core.cache/BasicCache">BasicCache</a>, <a href="#clojure.core.cache/FIFOCache">FIFOCache</a>, <a href="#clojure.core.cache/FnCache">FnCache</a>, <a href="#clojure.core.cache/LIRSCache">LIRSCache</a>, <a href="#clojure.core.cache/LRUCache">LRUCache</a>, <a href="#clojure.core.cache/LUCache">LUCache</a>, <a href="#clojure.core.cache/SoftCache">SoftCache</a>, <a href="#clojure.core.cache/TTLCacheQ">TTLCacheQ</a></span>
    <div id="proto-var-entry">
      <br />
      <h3 id="clojure.core.cache/evict">evict</h3>
      <span id="var-type">function</span><br />
      <pre id="var-usage">Usage: (evict cache e)
</pre>
      <pre id="var-docstr">Removes an entry from the cache</pre>
      <pre id="var-specs"></pre>
      
      
      
    </div><div id="proto-var-entry">
      <br />
      <h3 id="clojure.core.cache/has?">has?</h3>
      <span id="var-type">function</span><br />
      <pre id="var-usage">Usage: (has? cache e)
</pre>
      <pre id="var-docstr">Checks if the cache contains a value associated with `e`</pre>
      <pre id="var-specs"></pre>
      
      
      
    </div><div id="proto-var-entry">
      <br />
      <h3 id="clojure.core.cache/hit">hit</h3>
      <span id="var-type">function</span><br />
      <pre id="var-usage">Usage: (hit cache e)
</pre>
      <pre id="var-docstr">Is meant to be called if the cache is determined to contain a value
associated with `e`</pre>
      <pre id="var-specs"></pre>
      
      
      
    </div><div id="proto-var-entry">
      <br />
      <h3 id="clojure.core.cache/lookup">lookup</h3>
      <span id="var-type">function</span><br />
      <pre id="var-usage">Usage: (lookup cache e)
       (lookup cache e not-found)
</pre>
      <pre id="var-docstr">Retrieve the value associated with `e` if it exists, else `nil` in
the 2-arg case.  Retrieve the value associated with `e` if it exists,
else `not-found` in the 3-arg case.</pre>
      <pre id="var-specs"></pre>
      
      
      
    </div><div id="proto-var-entry">
      <br />
      <h3 id="clojure.core.cache/miss">miss</h3>
      <span id="var-type">function</span><br />
      <pre id="var-usage">Usage: (miss cache e ret)
</pre>
      <pre id="var-docstr">Is meant to be called if the cache is determined to **not** contain a
value associated with `e`</pre>
      <pre id="var-specs"></pre>
      
      
      
    </div><div id="proto-var-entry">
      <br />
      <h3 id="clojure.core.cache/seed">seed</h3>
      <span id="var-type">function</span><br />
      <pre id="var-usage">Usage: (seed cache base)
</pre>
      <pre id="var-docstr">Is used to signal that the cache should be created with a seed.
The contract is that said cache should return an instance of its
own type.</pre>
      <pre id="var-specs"></pre>
      
      
      
    </div>
    
    
    <a id="proto-source" href="https://github.com/clojure/core.cache/blob/430cf69a3e8a5ce00112e3534f0c06c70d5638d8/src/main/clojure/clojure/core/cache.clj#L20">Source</a>
  </div>
</div>
<div id="type-section">
  <p></p>
  <h2>Types</h2>
  <div id="type-entry">
    <br />
    <hr />
    <h2 id="clojure.core.cache/BasicCache">BasicCache</h2>
    <span id="type-type">type</span><br />
    <pre id="type-docstr"></pre>
    Fields: <span id="type-fields">[cache]</span><br />
    Protocols: <span id="type-protocols"><a href="#clojure.core.cache/CacheProtocol">CacheProtocol</a></span><br />
    Interfaces: <span id="type-interfaces">clojure.lang.Associative, clojure.lang.Counted, clojure.lang.ILookup, clojure.lang.IPersistentCollection, clojure.lang.IPersistentMap, clojure.lang.Seqable, java.lang.Iterable</span><br />
  </div><div id="type-entry">
    <br />
    <hr />
    <h2 id="clojure.core.cache/FIFOCache">FIFOCache</h2>
    <span id="type-type">type</span><br />
    <pre id="type-docstr"></pre>
    Fields: <span id="type-fields">[cache q limit]</span><br />
    Protocols: <span id="type-protocols"><a href="#clojure.core.cache/CacheProtocol">CacheProtocol</a></span><br />
    Interfaces: <span id="type-interfaces">clojure.lang.Associative, clojure.lang.Counted, clojure.lang.ILookup, clojure.lang.IPersistentCollection, clojure.lang.IPersistentMap, clojure.lang.Seqable, java.lang.Iterable</span><br />
  </div><div id="type-entry">
    <br />
    <hr />
    <h2 id="clojure.core.cache/FnCache">FnCache</h2>
    <span id="type-type">type</span><br />
    <pre id="type-docstr"></pre>
    Fields: <span id="type-fields">[cache f]</span><br />
    Protocols: <span id="type-protocols"><a href="#clojure.core.cache/CacheProtocol">CacheProtocol</a></span><br />
    Interfaces: <span id="type-interfaces">clojure.lang.Associative, clojure.lang.Counted, clojure.lang.ILookup, clojure.lang.IPersistentCollection, clojure.lang.IPersistentMap, clojure.lang.Seqable, java.lang.Iterable</span><br />
  </div><div id="type-entry">
    <br />
    <hr />
    <h2 id="clojure.core.cache/LIRSCache">LIRSCache</h2>
    <span id="type-type">type</span><br />
    <pre id="type-docstr"></pre>
    Fields: <span id="type-fields">[cache lruS lruQ tick limitS limitQ]</span><br />
    Protocols: <span id="type-protocols"><a href="#clojure.core.cache/CacheProtocol">CacheProtocol</a></span><br />
    Interfaces: <span id="type-interfaces">clojure.lang.Associative, clojure.lang.Counted, clojure.lang.ILookup, clojure.lang.IPersistentCollection, clojure.lang.IPersistentMap, clojure.lang.Seqable, java.lang.Iterable</span><br />
  </div><div id="type-entry">
    <br />
    <hr />
    <h2 id="clojure.core.cache/LRUCache">LRUCache</h2>
    <span id="type-type">type</span><br />
    <pre id="type-docstr"></pre>
    Fields: <span id="type-fields">[cache lru tick limit]</span><br />
    Protocols: <span id="type-protocols"><a href="#clojure.core.cache/CacheProtocol">CacheProtocol</a></span><br />
    Interfaces: <span id="type-interfaces">clojure.lang.Associative, clojure.lang.Counted, clojure.lang.ILookup, clojure.lang.IPersistentCollection, clojure.lang.IPersistentMap, clojure.lang.Seqable, java.lang.Iterable</span><br />
  </div><div id="type-entry">
    <br />
    <hr />
    <h2 id="clojure.core.cache/LUCache">LUCache</h2>
    <span id="type-type">type</span><br />
    <pre id="type-docstr"></pre>
    Fields: <span id="type-fields">[cache lu limit]</span><br />
    Protocols: <span id="type-protocols"><a href="#clojure.core.cache/CacheProtocol">CacheProtocol</a></span><br />
    Interfaces: <span id="type-interfaces">clojure.lang.Associative, clojure.lang.Counted, clojure.lang.ILookup, clojure.lang.IPersistentCollection, clojure.lang.IPersistentMap, clojure.lang.Seqable, java.lang.Iterable</span><br />
  </div><div id="type-entry">
    <br />
    <hr />
    <h2 id="clojure.core.cache/SoftCache">SoftCache</h2>
    <span id="type-type">type</span><br />
    <pre id="type-docstr"></pre>
    Fields: <span id="type-fields">[cache rcache rq]</span><br />
    Protocols: <span id="type-protocols"><a href="#clojure.core.cache/CacheProtocol">CacheProtocol</a></span><br />
    Interfaces: <span id="type-interfaces">clojure.lang.Associative, clojure.lang.Counted, clojure.lang.ILookup, clojure.lang.IPersistentCollection, clojure.lang.IPersistentMap, clojure.lang.Seqable, java.lang.Iterable</span><br />
  </div><div id="type-entry">
    <br />
    <hr />
    <h2 id="clojure.core.cache/TTLCacheQ">TTLCacheQ</h2>
    <span id="type-type">type</span><br />
    <pre id="type-docstr"></pre>
    Fields: <span id="type-fields">[cache ttl q gen ttl-ms]</span><br />
    Protocols: <span id="type-protocols"><a href="#clojure.core.cache/CacheProtocol">CacheProtocol</a></span><br />
    Interfaces: <span id="type-interfaces">clojure.lang.Associative, clojure.lang.Counted, clojure.lang.ILookup, clojure.lang.IPersistentCollection, clojure.lang.IPersistentMap, clojure.lang.Seqable, java.lang.Iterable</span><br />
  </div>
</div>
<div id="var-section">
  <p></p>
  <h2>Public Variables and Functions</h2>
  <div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.cache/-&gt;BasicCache">-&gt;BasicCache</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (-&gt;BasicCache cache)
</pre>
    <pre id="var-docstr">Positional factory function for class clojure.core.cache.BasicCache.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.cache/blob/430cf69a3e8a5ce00112e3534f0c06c70d5638d8/src/main/clojure/clojure/core/cache.clj#L115">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.cache/-&gt;FIFOCache">-&gt;FIFOCache</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (-&gt;FIFOCache cache q limit)
</pre>
    <pre id="var-docstr">Positional factory function for class clojure.core.cache.FIFOCache.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.cache/blob/430cf69a3e8a5ce00112e3534f0c06c70d5638d8/src/main/clojure/clojure/core/cache.clj#L173">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.cache/-&gt;FnCache">-&gt;FnCache</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (-&gt;FnCache cache f)
</pre>
    <pre id="var-docstr">Positional factory function for class clojure.core.cache.FnCache.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.cache/blob/430cf69a3e8a5ce00112e3534f0c06c70d5638d8/src/main/clojure/clojure/core/cache.clj#L135">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.cache/-&gt;LIRSCache">-&gt;LIRSCache</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (-&gt;LIRSCache cache lruS lruQ tick limitS limitQ)
</pre>
    <pre id="var-docstr">Positional factory function for class clojure.core.cache.LIRSCache.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.cache/blob/430cf69a3e8a5ce00112e3534f0c06c70d5638d8/src/main/clojure/clojure/core/cache.clj#L434">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.cache/-&gt;LRUCache">-&gt;LRUCache</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (-&gt;LRUCache cache lru tick limit)
</pre>
    <pre id="var-docstr">Positional factory function for class clojure.core.cache.LRUCache.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.cache/blob/430cf69a3e8a5ce00112e3534f0c06c70d5638d8/src/main/clojure/clojure/core/cache.clj#L211">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.cache/-&gt;LUCache">-&gt;LUCache</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (-&gt;LUCache cache lu limit)
</pre>
    <pre id="var-docstr">Positional factory function for class clojure.core.cache.LUCache.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.cache/blob/430cf69a3e8a5ce00112e3534f0c06c70d5638d8/src/main/clojure/clojure/core/cache.clj#L313">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.cache/-&gt;SoftCache">-&gt;SoftCache</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (-&gt;SoftCache cache rcache rq)
</pre>
    <pre id="var-docstr">Positional factory function for class clojure.core.cache.SoftCache.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.cache/blob/430cf69a3e8a5ce00112e3534f0c06c70d5638d8/src/main/clojure/clojure/core/cache.clj#L519">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.cache/-&gt;TTLCacheQ">-&gt;TTLCacheQ</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (-&gt;TTLCacheQ cache ttl q gen ttl-ms)
</pre>
    <pre id="var-docstr">Positional factory function for class clojure.core.cache.TTLCacheQ.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.cache/blob/430cf69a3e8a5ce00112e3534f0c06c70d5638d8/src/main/clojure/clojure/core/cache.clj#L269">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.cache/basic-cache-factory">basic-cache-factory</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (basic-cache-factory base)
</pre>
    <pre id="var-docstr">Returns a pluggable basic cache initialized to `base`</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.cache/blob/430cf69a3e8a5ce00112e3534f0c06c70d5638d8/src/main/clojure/clojure/core/cache.clj#L578">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.cache/fifo-cache-factory">fifo-cache-factory</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (fifo-cache-factory base &amp; {threshold :threshold, :or {threshold 32}})
</pre>
    <pre id="var-docstr">Returns a FIFO cache with the cache and FIFO queue initialized to `base` --
the queue is filled as the values are pulled out of `base`.  If the associative
structure can guarantee ordering, then the said ordering will define the
eventual eviction order.  Otherwise, there are no guarantees for the eventual
eviction ordering.

This function takes an optional `:threshold` argument that defines the maximum number
of elements in the cache before the FIFO semantics apply (default is 32).

If the number of elements in `base` is greater than the limit then some items
in `base` will be dropped from the resulting cache.  If the associative
structure used as `base` can guarantee sorting, then the last `limit` elements
will be used as the cache seed values.  Otherwise, there are no guarantees about
the elements in the resulting cache.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.cache/blob/430cf69a3e8a5ce00112e3534f0c06c70d5638d8/src/main/clojure/clojure/core/cache.clj#L584">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.cache/lirs-cache-factory">lirs-cache-factory</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (lirs-cache-factory base &amp; {:keys [s-history-limit q-history-limit], :or {s-history-limit 32, q-history-limit 32}})
</pre>
    <pre id="var-docstr">Returns an LIRS cache with the S &amp; R LRU lists set to the indicated
limits.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.cache/blob/430cf69a3e8a5ce00112e3534f0c06c70d5638d8/src/main/clojure/clojure/core/cache.clj#L637">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.cache/lru-cache-factory">lru-cache-factory</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (lru-cache-factory base &amp; {threshold :threshold, :or {threshold 32}})
</pre>
    <pre id="var-docstr">Returns an LRU cache with the cache and usage-table initialized to `base` --
each entry is initialized with the same usage value.

This function takes an optional `:threshold` argument that defines the maximum number
of elements in the cache before the LRU semantics apply (default is 32).</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.cache/blob/430cf69a3e8a5ce00112e3534f0c06c70d5638d8/src/main/clojure/clojure/core/cache.clj#L605">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.cache/lu-cache-factory">lu-cache-factory</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (lu-cache-factory base &amp; {threshold :threshold, :or {threshold 32}})
</pre>
    <pre id="var-docstr">Returns an LU cache with the cache and usage-table initialized to `base`.

This function takes an optional `:threshold` argument that defines the maximum number
of elements in the cache before the LU semantics apply (default is 32).</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.cache/blob/430cf69a3e8a5ce00112e3534f0c06c70d5638d8/src/main/clojure/clojure/core/cache.clj#L627">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.cache/soft-cache-factory">soft-cache-factory</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (soft-cache-factory base)
</pre>
    <pre id="var-docstr">Returns a SoftReference cache.  Cached values will be referred to with
SoftReferences, allowing the values to be garbage collected when there is
memory pressure on the JVM.

SoftCache is a mutable cache, since it is always based on a
ConcurrentHashMap.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.cache/blob/430cf69a3e8a5ce00112e3534f0c06c70d5638d8/src/main/clojure/clojure/core/cache.clj#L648">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.cache/through">through</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (through cache item)
       (through value-fn cache item)
       (through wrap-fn value-fn cache item)
</pre>
    <pre id="var-docstr">The basic hit/miss logic for the cache system.  Expects a wrap function and
value function.  The wrap function takes the value function and the item in question
and is expected to run the value function with the item whenever a cache
miss occurs.  The intent is to hide any cache-specific cells from leaking
into the cache logic itelf.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.cache/blob/430cf69a3e8a5ce00112e3534f0c06c70d5638d8/src/main/clojure/clojure/core/cache.clj#L44">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.cache/through-cache">through-cache</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (through-cache cache item)
       (through-cache cache item value-fn)
       (through-cache cache item wrap-fn value-fn)
</pre>
    <pre id="var-docstr">The basic hit/miss logic for the cache system.  Like through but always has
the cache argument in the first position for easier use with swap! etc.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.cache/blob/430cf69a3e8a5ce00112e3534f0c06c70d5638d8/src/main/clojure/clojure/core/cache.clj#L57">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.cache/ttl-cache-factory">ttl-cache-factory</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (ttl-cache-factory base &amp; {ttl :ttl, :or {ttl 2000}})
</pre>
    <pre id="var-docstr">Returns a TTL cache with the cache and expiration-table initialized to `base` --
each with the same time-to-live.

This function also allows an optional `:ttl` argument that defines the default
time in milliseconds that entries are allowed to reside in the cache.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.cache/blob/430cf69a3e8a5ce00112e3534f0c06c70d5638d8/src/main/clojure/clojure/core/cache.clj#L616">Source</a>
  </div>
</div>

<br />
<h2 id="clojure.core.cache.wrapped">clojure.core.cache.wrapped</h2>
<pre id="namespace-docstr">A higher level way to use clojure.core.cache that assumes the immutable
cache is wrapped in an atom.

The API is (almost) the same as clojure.core.cache -- including the factory
functions -- but instead of accepting immutable caches, the functions
here accept atoms containing those caches. The factory functions return
new atoms containing the newly created cache.

In addition, lookup-or-miss provides a safe, atomic way to retrieve a
value from a cache or compute it if it is missing, without risking a
cache stampede.</pre>


<br />


<div id="var-section">
  <p></p>
  <h2>Public Variables and Functions</h2>
  <div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.cache.wrapped/basic-cache-factory">basic-cache-factory</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (basic-cache-factory base)
</pre>
    <pre id="var-docstr">Returns a pluggable basic cache initialized to `base`</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.cache/blob/9038e65b5d0d2c256c68740007e29ef115ac3ec6/src/main/clojure/clojure/core/cache/wrapped.clj#L130">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.cache.wrapped/evict">evict</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (evict cache-atom e)
</pre>
    <pre id="var-docstr">Removes an entry from the cache.

Returns the updated cache from the atom.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.cache/blob/9038e65b5d0d2c256c68740007e29ef115ac3ec6/src/main/clojure/clojure/core/cache/wrapped.clj#L95">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.cache.wrapped/fifo-cache-factory">fifo-cache-factory</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (fifo-cache-factory base &amp; {threshold :threshold, :or {threshold 32}})
</pre>
    <pre id="var-docstr">Returns a FIFO cache with the cache and FIFO queue initialized to `base` --
the queue is filled as the values are pulled out of `base`.  If the associative
structure can guarantee ordering, then the said ordering will define the
eventual eviction order.  Otherwise, there are no guarantees for the eventual
eviction ordering.

This function takes an optional `:threshold` argument that defines the maximum number
of elements in the cache before the FIFO semantics apply (default is 32).

If the number of elements in `base` is greater than the limit then some items
in `base` will be dropped from the resulting cache.  If the associative
structure used as `base` can guarantee sorting, then the last `limit` elements
will be used as the cache seed values.  Otherwise, there are no guarantees about
the elements in the resulting cache.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.cache/blob/9038e65b5d0d2c256c68740007e29ef115ac3ec6/src/main/clojure/clojure/core/cache/wrapped.clj#L135">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.cache.wrapped/has?">has?</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (has? cache-atom e)
</pre>
    <pre id="var-docstr">Checks if the cache contains a value associated with `e`.

Reads from the current version of the atom.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.cache/blob/9038e65b5d0d2c256c68740007e29ef115ac3ec6/src/main/clojure/clojure/core/cache/wrapped.clj#L72">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.cache.wrapped/hit">hit</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (hit cache-atom e)
</pre>
    <pre id="var-docstr">Is meant to be called if the cache is determined to contain a value
associated with `e`.

Returns the updated cache from the atom. Provided for completeness.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.cache/blob/9038e65b5d0d2c256c68740007e29ef115ac3ec6/src/main/clojure/clojure/core/cache/wrapped.clj#L79">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.cache.wrapped/lirs-cache-factory">lirs-cache-factory</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (lirs-cache-factory base &amp; {:keys [s-history-limit q-history-limit], :or {s-history-limit 32, q-history-limit 32}})
</pre>
    <pre id="var-docstr">Returns an LIRS cache with the S &amp; R LRU lists set to the indicated
limits.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.cache/blob/9038e65b5d0d2c256c68740007e29ef115ac3ec6/src/main/clojure/clojure/core/cache/wrapped.clj#L179">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.cache.wrapped/lookup">lookup</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (lookup cache-atom e)
       (lookup cache-atom e not-found)
</pre>
    <pre id="var-docstr">Retrieve the value associated with `e` if it exists, else `nil` in
the 2-arg case.  Retrieve the value associated with `e` if it exists,
else `not-found` in the 3-arg case.

Reads from the current version of the atom.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.cache/blob/9038e65b5d0d2c256c68740007e29ef115ac3ec6/src/main/clojure/clojure/core/cache/wrapped.clj#L25">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.cache.wrapped/lookup-or-miss">lookup-or-miss</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (lookup-or-miss cache-atom e value-fn)
       (lookup-or-miss cache-atom e wrap-fn value-fn)
</pre>
    <pre id="var-docstr">Retrieve the value associated with `e` if it exists, else compute the
value (using value-fn, and optionally wrap-fn), update the cache for `e`
and then perform the lookup again.

value-fn (and wrap-fn) will only be called (at most) once even in the
case of retries, so there is no risk of cache stampede.

Since lookup can cause invalidation in some caches (such as TTL), we
trap that case and retry (a maximum of ten times).</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.cache/blob/9038e65b5d0d2c256c68740007e29ef115ac3ec6/src/main/clojure/clojure/core/cache/wrapped.clj#L38">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.cache.wrapped/lru-cache-factory">lru-cache-factory</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (lru-cache-factory base &amp; {threshold :threshold, :or {threshold 32}})
</pre>
    <pre id="var-docstr">Returns an LRU cache with the cache and usage-table initialized to `base` --
each entry is initialized with the same usage value.

This function takes an optional `:threshold` argument that defines the maximum number
of elements in the cache before the LRU semantics apply (default is 32).</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.cache/blob/9038e65b5d0d2c256c68740007e29ef115ac3ec6/src/main/clojure/clojure/core/cache/wrapped.clj#L153">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.cache.wrapped/lu-cache-factory">lu-cache-factory</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (lu-cache-factory base &amp; {threshold :threshold, :or {threshold 32}})
</pre>
    <pre id="var-docstr">Returns an LU cache with the cache and usage-table initialized to `base`.

This function takes an optional `:threshold` argument that defines the maximum number
of elements in the cache before the LU semantics apply (default is 32).</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.cache/blob/9038e65b5d0d2c256c68740007e29ef115ac3ec6/src/main/clojure/clojure/core/cache/wrapped.clj#L171">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.cache.wrapped/miss">miss</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (miss cache-atom e ret)
</pre>
    <pre id="var-docstr">Is meant to be called if the cache is determined to **not** contain a
value associated with `e`.

Returns the updated cache from the atom. Provided for completeness.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.cache/blob/9038e65b5d0d2c256c68740007e29ef115ac3ec6/src/main/clojure/clojure/core/cache/wrapped.clj#L87">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.cache.wrapped/seed">seed</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (seed cache-atom base)
</pre>
    <pre id="var-docstr">Is used to signal that the cache should be created with a seed.
The contract is that said cache should return an instance of its
own type.

Returns the updated cache from the atom. Provided for completeness.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.cache/blob/9038e65b5d0d2c256c68740007e29ef115ac3ec6/src/main/clojure/clojure/core/cache/wrapped.clj#L102">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.cache.wrapped/soft-cache-factory">soft-cache-factory</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (soft-cache-factory base)
</pre>
    <pre id="var-docstr">Returns a SoftReference cache.  Cached values will be referred to with
SoftReferences, allowing the values to be garbage collected when there is
memory pressure on the JVM.

SoftCache is a mutable cache, since it is always based on a
ConcurrentHashMap.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.cache/blob/9038e65b5d0d2c256c68740007e29ef115ac3ec6/src/main/clojure/clojure/core/cache/wrapped.clj#L189">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.cache.wrapped/through">through</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (through cache-atom item)
       (through value-fn cache-atom item)
       (through wrap-fn value-fn cache-atom item)
</pre>
    <pre id="var-docstr">The basic hit/miss logic for the cache system.  Expects a wrap function and
value function.  The wrap function takes the value function and the item in question
and is expected to run the value function with the item whenever a cache
miss occurs.  The intent is to hide any cache-specific cells from leaking
into the cache logic itelf.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.cache/blob/9038e65b5d0d2c256c68740007e29ef115ac3ec6/src/main/clojure/clojure/core/cache/wrapped.clj#L111">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.cache.wrapped/through-cache">through-cache</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (through-cache cache-atom item)
       (through-cache cache-atom item value-fn)
       (through-cache cache-atom item wrap-fn value-fn)
</pre>
    <pre id="var-docstr">The basic hit/miss logic for the cache system.  Like through but always has
the cache argument in the first position.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.cache/blob/9038e65b5d0d2c256c68740007e29ef115ac3ec6/src/main/clojure/clojure/core/cache/wrapped.clj#L122">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.cache.wrapped/ttl-cache-factory">ttl-cache-factory</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (ttl-cache-factory base &amp; {ttl :ttl, :or {ttl 2000}})
</pre>
    <pre id="var-docstr">Returns a TTL cache with the cache and expiration-table initialized to `base` --
each with the same time-to-live.

This function also allows an optional `:ttl` argument that defines the default
time in milliseconds that entries are allowed to reside in the cache.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.cache/blob/9038e65b5d0d2c256c68740007e29ef115ac3ec6/src/main/clojure/clojure/core/cache/wrapped.clj#L162">Source</a>
  </div>
</div>


</div>
              </div>
            </div>
          </div>
	</div>
	<div id="foot">
	  <div id="copyright" style="text-align: center;">Copyright 2007-2023 by Rich Hickey and the various contributors</div>
	</div>
      </div>
      <div id="DesignedBy">Logo &amp; site design by <a href="http://www.tomhickey.com" title="Visit Tom Hickey's website.">Tom Hickey</a>.<br />
      Clojure auto-documentation system by Tom Faulhaber.</div>
    </div>
    <!-- /AllContentContainer -->
  </body>

</html>